---
title: "BGD geo-spatial automated"
output: html_document
date: "2023-05-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load packages ##

R tools will also be required

```{r library, include=FALSE}
library("tiff")           # opening geoTIFF files
library("raster")         # raster manipulation
library("sf")             # working with shapefiles
library("ggplot2")        # plots
library("RColorBrewer")   # Funky graph colors 
library("rworldmap")      # Mapping country boundaries
library("haven")          # Opening stata files
library("gsubfn")         # String operations
library("viridis")        # Nice colour palette
library("rgdal")          # package for geospatial analysis
library("sp")             # geo-spatial analysis
library("PopED")          # modelling of zonal statistics 
library("plyr")
library("dplyr")
library("readr")
library("dichromat")
```

##  STEP 1 - Load the base layer for Bangladesh  and shapefile with admin level 3 ##


```{r base layer, echo=TRUE}
# Set working directory 
setwd("C:/Users/idabr/OneDrive - Oxford Policy Management Limited/EMDI SAE/Geo-spatial Bangaldesh data/Base layers")

# Load the WordPop Administrative Level 0 mastergrid base layer for Bangladesh 
bangladesh_base <- 'bgd_level0_100m_2000_2020.tif'
bgd_base_raster=raster(bangladesh_base)

# Plot raster
plot(bgd_base_raster, box=F, axes=F,legend=F, main = "Bangladesh base layer")
```

# Load the shapefile with administrative level 3 for Bangladesh #

```{r admin 3, echo=TRUE}
# Set working directory 
setwd("C:/Users/idabr/OneDrive - Oxford Policy Management Limited/EMDI SAE/Geo-spatial Bangaldesh data/Base layers/admin 3 level")

# Load the shapefile
bgd_admin3 <- st_read("bgd_admbnda_adm3_bbs_20201113.shp")

# Check geometry type - multipolygon
#st_geometry_type(bgd_admin3)

# Check CRS - WGS 84
st_crs(bgd_admin3)

# See the extent - this returns min and max geographical coordinates 
st_bbox(bgd_admin3)

# See metadata associated with the shapefile
bgd_admin3

# Alternative way of loading the shapefile
bgd_test <- readOGR("bgd_admbnda_adm3_bbs_20201113.shp")

# Plot the shape file 
ggplot() + 
  geom_sf(data = bgd_admin3, size = 3, color = "black", fill = "cyan1") + 
  ggtitle("Administrative Level 3 Bangladesh") + 
  coord_sf() + theme_minimal()
```
## STEP 2 - write function for automated processing of geo-spatial covariates  ##

```{r function, echo=TRUE}
# Function for automating the processing of geo-spatial covariates for use in poverty modelling
geo_process <- function(aux.raster, base.raster, label, value) {

    # Crop to the base layer so they have the same extent
    r <- crop(aux.raster, base.raster)

    # Change resolution to the resolution of the base layer using nearest neighbour interpolation
    r <- resample(r, base.raster, method = "ngb") 
    
    # Replace NA with a specified value (if appropriate)
    r[is.na(r[])] <- value  

    # Select only the shape of Bangladesh as defined by the base layer
    r <- mask(x = r, mask = base.raster)
    
    
    # Assign a name to the raster
    names(r) <- label
    return(r)
    
}

```


##  STEP 3 - apply the function to process data on accessibility from Malaria Atlas, demographic maps from Facebook, and Nightlights data ##

## Malaria Atlas ##


```{r malaria atlas, echo=TRUE}
# Make a list of all TIFF files from the Malaria Atlas Project and import those into a list 
current.list <- list.files(path="C:/Users/idabr/OneDrive - Oxford Policy Management Limited/EMDI SAE/Geo-spatial Bangaldesh data/Travel time - Malaria Atlas Project", pattern =".tiff", full.names=TRUE)

# Turn all files into a raster and make a list of rasters
rlist <- lapply(current.list, raster)

# See that all the files have loaded
rlist

# Now apply this function to a list of rasters from the Malaria Atlas 

# Make a list for storing the processed rasters 
rlist_processed <- list()

# Store the length of the list of rasters
num_r <- 1:length(rlist)  

# Apply the geo-processing function to all rasters. Here there is no need to replace missing values as 0s (they are already coded as missing), so the parameter for value can stay at NA.
for (i in num_r) { 
rlist_processed[[i]] <- geo_process(aux.raster = rlist[[i]], base.raster = bgd_base_raster, label = rlist[[i]]@data@names, value = NA)

}

# See the result
rlist_processed

# Plot results 
plot(rlist_processed[[1]], box=F, axes=F, col=viridis(50), main = "Bangladesh - Travel Time to Cities")
plot(rlist_processed[[2]], box=F, axes=F, col=viridis(50), main = "Bangladesh - Motorised Travel Time to Healthcare Facilities")
plot(rlist_processed[[3]], box=F, axes=F, col=viridis(50), main = "Bangladesh - Walking-Only Travel Time to Healthcare Facilities")

# Create a high quality image 
png(filename="BGD travel time city.png", res=400, width=2000, height=1500)
plot(rlist_processed[[1]], box=F, axes=F, col=viridis(50), main = "Bangladesh - Travel Time to Cities")
dev.off()

```

## Facebook Demographic Maps ##

Note: this automated processing takes ages even with a good laptop 

```{r meta demography, echo=TRUE}
# Pull all TIFF files from Meta with demographic maps
# Note: All files must be nicely pulled out of their folders after unzipping so that they are available in the location below 
demography.list <- list.files(path="C:/Users/idabr/OneDrive - Oxford Policy Management Limited/EMDI SAE/Geo-spatial Bangaldesh data/Demographic maps Facebook/", pattern =".tif", full.names=TRUE)

# Turn all files into a raster and make a list of rasters
fb.list <- lapply(demography.list, raster)

# Check that all the files were picked up by this 
fb.list

# Make a list for storing the processed rasters 
fblist_processed <- list()

# Store the length of the list of rasters
num_fb <- 1:length(fb.list)  

# Apply the geo-processing function to all rasters. Here we need to recode missing values as 0s
for (i in num_fb) { 
fblist_processed[[i]] <- geo_process(aux.raster = fb.list[[i]], base.raster = bgd_base_raster, label = fb.list[[i]]@data@names, value = 0)

}

# See the result
fblist_processed

# Plot results
plot(fblist_processed[[1]], box=F, axes=F, main = "Bangladesh - Population density (children under 5)")
plot(fblist_processed[[2]], box=F, axes=F, main = "Bangladesh - Population density (elderly 60+)")
plot(fblist_processed[[3]], box=F, axes=F, main = "Bangladesh - Population density (general)")
plot(fblist_processed[[4]], box=F, axes=F, main = "Bangladesh - Population density (men)")
plot(fblist_processed[[5]], box=F, axes=F, main = "Bangladesh - Population density (women)")
plot(fblist_processed[[6]], box=F, axes=F, main = "Bangladesh - Population density (women of reproductive age 15-49)")
plot(fblist_processed[[7]], box=F, axes=F, main = "Bangladesh - Population density (youth 15-24)")


# Create a high quality image 
png(filename="simple_graphic.png", res=400, width=2000, height=1500)
plot(fblist_processed[[7]], box=F, axes=F, main = "Bangladesh - Population density (youth 15-24)")
dev.off()

```

## Nightlights Data ##

```{r nightlights, echo=TRUE}
# Set working directory
setwd("C:/Users/idabr/OneDrive - Oxford Policy Management Limited/EMDI SAE/Geo-spatial Bangaldesh data/Nightlights data/SVDNB_npp_20150101-20151231_75N0/SVDNB_npp_20150101-20151231_75N060E_v10_c201701311200")

# Import geoTIFF file on nightlights intensity
nightlights <- 'SVDNB_npp_20150101-20151231_75N060E_vcm-orm_v10_c201701311200.avg_rade9.tif'

# Turn into a raster for plotting 
nightlights_raster = raster(nightlights) 

# Apply the geo processing function
nightlights_raster <- geo_process(aux.raster = nightlights_raster, base.raster = bgd_base_raster, label = nightlights_raster@data@names, value = 0)

# Check raster
nightlights_raster

# Plot raster 
plot(nightlights_raster, axes=F, box=F, main = "Nightlights data in Bangladesh", col=cividis(50))

# Create a high quality image 
png(filename="nightlights_BGD.png", res=400, width=2000, height=1500)
plot(nightlights_raster, box=F, axes=F, main = "Nightlights data in Bangladesh", col=cividis(50))
dev.off()

```
## STEP 4 - Convert the Bangladesh shapefile to a raster for calculation of zonal statistics ##

```{r shp to raster, echo=TRUE}
# Copy admin unit codes to new column in upazila shapefile attributes, in the process removing Bangladesh prefix from the integer code
bgd_test@data$adm3_integer <- substr(bgd_test@data[["ADM3_PCODE"]], 3, 10)

# Turn into numeric
bgd_test@data[["adm3_integer"]] <- as.numeric(bgd_test@data[["adm3_integer"]])

# Convert upazila shapefile to raster using the integer admin unit code, maintaining extent and cell size of L0 base layer
## Set up a raster "template" to use in rasterize()
ext_base <-  extent(bgd_base_raster)
ncol_base <- bgd_base_raster@ncols
nrow_base <- bgd_base_raster@nrows

xy <- abs(apply(as.matrix(bbox(ext_base)), 1, diff))
r <- raster(ext_base, ncol=ncol_base, nrow=nrow_base)

## Rasterize the shapefile
raster_admin3 <-rasterize(bgd_test, r, field=bgd_test$adm3_integer)

# Assign the same CRS as the base layer 
crs_base <- crs(bgd_base_raster)
crs(raster_admin3) <- crs_base

# Plot to see if values have been assigned to the raster
plot(raster_admin3, box=F, axes=F)

```
## STEP 5 - Import pre-harmonised geodata from World Pop ##

```{r worldpop harmonised, echo=TRUE}
#set working directory
setwd("C:/Users/idabr/OneDrive - Oxford Policy Management Limited/EMDI SAE/Geo-spatial Bangaldesh data/World Pop Harmonised Datasets")

# Make a list of all TIFF files from WorldPop and import those into a list 
worldpop.list <- list.files(path="C:/Users/idabr/OneDrive - Oxford Policy Management Limited/EMDI SAE/Geo-spatial Bangaldesh data/World Pop Harmonised Datasets", pattern =".tif", full.names=TRUE)

# Turn all files into a raster and make a list of rasters
worldpop.list <- lapply(worldpop.list, raster)

# See that all the files have loaded
worldpop.list

#Plot examples of WorldPop datasets
plot(worldpop.list[[11]], box = F, axes = F, main = "Distance to the closest road Bangladesh", col=viridis(50))

```


## STEP 6 - Calculation of zonal statistics at upazila level ##

From both the pre-harmonised WorldPop datasets and previously processed geo-spatial datasets

```{r zonal stats, echo=TRUE}
# Make a list with all the rasters 
full.raster.list <- c(rlist_processed, fblist_processed, worldpop.list)

# Add nightlights data to the list - 27th element
full.raster.list[[27]] <- nightlights_raster

# Check rasters 
full.raster.list

# Create a raster stack
raster.stack <- stack(full.raster.list)

# Zonal statistics 

# Mean
zonal.stats.mean <- zonal(raster.stack, raster_admin3, fun='mean', digits=6, na.rm=TRUE)
zonal.stats.mean <- as.data.frame(zonal.stats.mean)
colnames_mean <- colnames(zonal.stats.mean)  # gather column names
colnames_mean <- paste(colnames_mean, "mean", sep="_")  # add identifier for mean
colnames_mean <- colnames_mean[2:28]  # exclude zone
colnames(zonal.stats.mean)[2:28] <- colnames_mean  # rename columns
 

# Min
zonal.stats.min <- zonal(raster.stack, raster_admin3, fun='min', digits=6, na.rm=TRUE)
zonal.stats.min <- as.data.frame(zonal.stats.min)
colnames_min <- colnames(zonal.stats.min)
colnames_min <- paste(colnames_min, "min", sep="_")
colnames(zonal.stats.min)[2:28] <- colnames_min[2:28]

# Max
zonal.stats.max <- zonal(raster.stack, raster_admin3, fun='max', digits=6, na.rm=TRUE)
zonal.stats.max <- as.data.frame(zonal.stats.max)
colnames_max <- colnames(zonal.stats.max)
colnames_max <- paste(colnames_max, "max", sep="_")
colnames(zonal.stats.max)[2:28] <- colnames_max[2:28]

# Sum
zonal.stats.sum <- zonal(raster.stack, raster_admin3, fun='sum', digits=6, na.rm=TRUE)
zonal.stats.sum <- as.data.frame(zonal.stats.sum)
colnames_sum <- colnames(zonal.stats.sum)
colnames_sum <- paste(colnames_sum, "max", sep="_")
colnames(zonal.stats.sum)[2:28] <- colnames_sum[2:28]

# SD
zonal.stats.sd <- zonal(raster.stack, raster_admin3, fun='sd', digits=6, na.rm=TRUE)
zonal.stats.sd <- as.data.frame(zonal.stats.sd)
colnames_sd <- colnames(zonal.stats.sd)
colnames_sd <- paste(colnames_sd, "max", sep="_")
colnames(zonal.stats.sd)[2:28] <- colnames_sd[2:28]

# Count
zonal.stats.count <- zonal(raster.stack, raster_admin3, fun='count', digits=6, na.rm=TRUE)
zonal.stats.count <- as.data.frame(zonal.stats.count)
colnames_count <- colnames(zonal.stats.count)
colnames_count <- paste(colnames_count, "count", sep="_")
colnames(zonal.stats.count)[2:28] <- colnames_count[2:28]

# Make a list of all dataframes that contain zonal statistics
l.df <- lapply(ls(pattern="zonal.stats"), function(x) get(x))

# Combine all zonal statistics into one data frame 
zonal.stats.all <- bind_cols(l.df)

# Delete repeated columns for zones - occurs every 28 variables 
zonal.stats.all = subset(zonal.stats.all, select = -c(29, 57, 85, 113, 141)) 

# Rename the colum with upazila codes
colnames(zonal.stats.all)[1] <- "upazila.code"

# Save file 
save(zonal.stats.all, file = "BGD.zonalstats.RData")

```


# STEP 7 - Compare estimates to those from Southampton #

Looks like: for pre-harmonised WorldPop covariates, nightlights data, and accessibility datasets the zonal statistics end up being almost exactly the same. 

The issue is with demographic maps from Facebook, which come up with a completely different metric. Need to look into this. 

```{r compare estimates, echo=TRUE}
# Load the ready covariates we received from Nikos 
load("C:/Users/idabr/OneDrive - Oxford Policy Management Limited/EMDI SAE/Geo-spatial Bangaldesh data/Harmonised data Nikos/final.cov.est.new.Rdata")

# Compare summary stats - for example population density for children under 5 yields different values
summary(final.cov.est$CHILU5.MEAN)
summary(zonal.stats.all$bgd_children_under_five_2020_mean)

# Let's look at pre-harmonised World Pop covariates, which did not require any geo-spatial processing
summary(final.cov.est$DSTROAD.MEAN)
summary(zonal.stats.all$osm_dst_road_100m_2016_BGD_mean)

# These values look exactly the same 

# Let's check access to city - these are also super similar 
summary(final.cov.est$ACCCITY.MEAN)
summary(zonal.stats.all$X201501_Global_Travel_Time_to_Cities_BGD_mean)

# Have a look at nightlights - also super similar
summary(final.cov.est$VIIRS.MEAN)
summary(zonal.stats.all$SVDNB_npp_20150101.20151231_75N060E_vcm.orm_v10_c201701311200.avg_rade9_mean)
```


